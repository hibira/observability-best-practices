# ログ

ログは、アプリケーションまたはアプライアンスから送信される一連のメッセージで、イベントの詳細や、そのアプリケーションの健全性に関する 1 行または複数行の情報で表されます。通常、ログはファイルに出力されますが、時にはログを収集し、分析と集約を行うコレクターに送信されることもあります。ログの生成、取り込み、管理を、1 日あたり数メガバイトから 1 時間あたり数テラバイトまでの任意の量で行うことを目的とした、多くの高機能なログ集約ツール、フレームワーク、製品があります。

ログは 1 つのアプリケーションから順次出力され、通常はその*1 つのアプリケーション*の範囲に関するものですが、開発者は複雑で微妙なログを作成することもできます。ここでは、ログを [トレース](../../signals/traces) とは根本的に異なるシグナルと考えています。トレースは複数のアプリケーションやサービスからのイベントで構成され、レスポンス待ち時間、サービス障害、リクエストパラメータなどのサービス間の接続に関する文脈が含まれています。

ログのデータは一定期間にわたって集約することもできます。例えば、統計的なデータ (前分の要求数など) になる場合があります。構造化された、自由形式の、冗長な、あらゆる書き言葉のログが存在します。

ログの主な使用例は次のとおりです。

* イベントの説明 (ステータス、期間、その他の重要な統計情報を含む)
* そのイベントに関するエラーや警告 (スタックトレース、タイムアウトなど)
* アプリケーションの起動、開始、終了メッセージ

!!! note
	ログは*イミュータブル(不変)*であることが意図されており、多くのログ管理システムには、ログデータの変更を防ぐ、および変更の試みを検出するメカニズムが含まれています。

ログに関する要件にかかわらず、以下が私たちが特定したベストプラクティスです。

## 構造化されたログは成功の鍵

多くのシステムは半構造化された形式でログを出力します。例えば、Apache Webサーバーは次のように、1行ごとにWebリクエストに関する情報を出力します。

    192.168.2.20 - - [28/Jul/2006:10:27:10 -0300] "GET /cgi-bin/try/ HTTP/1.0" 200 3395
    127.0.0.1 - - [28/Jul/2006:10:22:04 -0300] "GET / HTTP/1.0" 200 2216

一方、Javaのスタックトレースは、複数行にわたる単一のイベントで、構造化されていません。

    Exception in thread "main" java.lang.NullPointerException
        at com.example.myproject.Book.getTitle(Book.java:16)
        at com.example.myproject.Author.getBookTitles(Author.java:25)
        at com.example.myproject.Bootstrap.main(Bootstrap.java:14)

また、Pythonのエラーログイベントは次のようになります。

    Traceback (most recent call last):
      File "e.py", line 7, in <module>
        raise TypeError("Again !?!")
    TypeError: Again !?!

これら3つの例のうち、人間と集約システムの両方で簡単に解析できるのは最初の例だけです。構造化されたログを使用すると、ログデータを迅速かつ効果的に処理でき、人間とマシンの両方が必要なデータをすぐに見つけることができます。

最も一般的に理解されるログ形式はJSONで、各イベントの構成要素がキー/値のペアとして表されます。JSONでは、上記のPythonの例は次のように書き換えられます。

    {
        "level", "ERROR"
        "file": "e.py",
        "line": 7,
        "error": "TypeError(\"Again !?!\")"
    }

構造化されたログを使用すると、ログシステム間でデータを移植できるようになり、開発が簡素化され、運用診断が高速化(エラーも少なく)されます。また、JSONにはログメッセージのスキーマと実際のデータが埋め込まれているため、高度なログ分析システムがメッセージを自動的にインデックス化できます。
</module>

## ログレベルを適切に使用する

ログには 2 種類あります。*レベル* を持つものと、一連のイベントのものです。レベルを持つログは、成功したロギング戦略の重要な要素です。ログレベルはフレームワークによってわずかに異なりますが、一般的にこの構造に従います。

| レベル | 説明 |
| ----- | ----------- |
| `DEBUG` | アプリケーションのデバッグに最も役立つ、細かい情報イベント。開発者にとって価値があり、非常に詳細です。 |
| `INFO` | アプリケーションの進捗状況を大まかに示す情報メッセージ。 |
| `WARN` | アプリケーションにリスクがあることを示す、潜在的に有害な状況。アプリケーションでアラームをトリガーする可能性があります。 |
| `ERROR` | アプリケーションが実行を続けられるかもしれないエラーイベント。注意が必要なアラームをトリガーする可能性が高いです。 |
| `FATAL` | おそらくアプリケーションを中止させる、非常に深刻なエラーイベント。 |

!!! info
	明示的なレベルが指定されていないログは、`INFO` と見なされる場合がありますが、この動作はアプリケーションによって異なります。

他の一般的なログレベルは、ニーズ、プログラミング言語、フレームワークによって、`CRITICAL` と `NONE` があります。`ALL` と `NONE` も一般的ですが、すべてのアプリケーションスタックで見られるわけではありません。

ログレベルは、環境の健全性についてモニタリングとオブザーバビリティソリューションに通知するのに重要です。ログデータは論理的な値を使ってこのデータを簡単に表現できるはずです。

!!! tip
	`WARN` レベルでデータを多く記録すると、モニタリングシステムが価値の限られたデータで一杯になり、膨大なメッセージの量で重要なデータを見失う可能性があります。

![ログフローチャート](./images/logs1.png)

!!! success
	標準化されたログレベル戦略を使用すると、自動化が容易になり、開発者が問題の根本原因をすばやく特定できるようになります。

!!! warning
	ログレベルに標準的なアプローチがないと、[ソース付近でのログのフィルタリング](#filter-logs-close-to-the-source)が大きな課題になります。

## ソース近くでログをフィルタリングする

可能な限り、ソースに近い場所でログの量を減らすことが重要です。このベストプラクティスに従う理由は次のとおりです。

* ログの取り込みには常に時間、費用、リソースがかかります。
* 下流のシステムから機密データ (個人を特定できるデータなど) をフィルタリングすると、データ漏洩のリスクが軽減されます。
* 下流のシステムは、データソースと同じ運用上の懸念がない場合があります。たとえば、アプリケーションからの `INFO` ログは、`CRITICAL` または `FATAL` メッセージを監視するモニタリングおよびアラートシステムでは関心がない可能性があります。
* ログシステムやネットワークに過度の負荷やトラフィックがかからないようにする必要があります。

!!! success
ソース近くでログをフィルタリングすれば、コストを抑え、データ漏洩のリスクを減らし、各コンポーネントを[重要なこと](../../guides/#monitor-what-matters)に集中させることができます。

!!! tip
アーキテクチャによっては、アプリケーションと環境の変更を 1 つの操作で展開するために、インフラストラクチャ as コード (IaC) を使用することをお勧めします。このアプローチでは、ログフィルターパターンをアプリケーションと同じ厳格さと処理で展開できます。

## 二重取り込みのアンチパターンを避ける

管理者が一般的に行うパターンは、すべてのログデータを単一のシステムにコピーし、単一の場所からすべてのログを照会することです。このようにすることには、マニュアルワークフローの利点がありますが、追加のコスト、複雑さ、障害ポイント、運用オーバーヘッドが発生します。

![二重ログ取り込み](./images/logs2.png)

!!! success
	可能な限り、[ログレベル](#use-log-levels-appropriately)と[ログフィルタリング](#filter-logs-close-to-the-source)の組み合わせを使用して、環境からのログデータの一括伝播を避けてください。

!!! info
	一部の組織やワークロードでは、規制要件を満たす、ログを安全な場所に保存する、非再現性を提供する、または他の目的を達成するために[ログ転送](https://en.wikipedia.org/wiki/Log_shipping)が必要になる場合があります。これは、ログデータを再取り込みするための一般的なユースケースです。[ログレベル](#use-log-levels-appropriately)と[ログフィルタリング](#filter-logs-close-to-the-source)を適切に適用して、これらのログアーカイブに入る無用なデータの量を減らすことも適切です。

## ログからメトリクスデータを収集する

ログには、収集を待っている[メトリクス](../../signals/metrics/)が含まれています! 自分で書いていないISVソリューションやアプリケーションでも、ワークロードの全体的な健全性に関する有益な洞察を得られるデータをログに出力します。一般的な例は次のとおりです。

* データベースからの遅いクエリ時間
* Webサーバーの稼働時間
* トランザクション処理時間
* 時間経過に伴う `ERROR` または `WARNING` イベントの数
* アップグレード可能なパッケージの生の数

!!! tip
	このデータは静的なログファイルに閉じ込められていると役に立ちません。ベストプラクティスは、重要なメトリクスデータを特定し、他のシグナルと相関させることができるメトリクスシステムに公開することです。

## `stdout` にログを出力する

可能な場合、アプリケーションはファイルやソケットなどの固定された場所にログを出力するのではなく、`stdout` にログを出力するべきです。これにより、ログエージェントがルールに基づいてログイベントを収集およびルーティングし、独自のオブザーバビリティソリューションに適したログ管理を行えるようになります。すべてのアプリケーションで可能というわけではありませんが、これはコンテナ化されたワークロードにおけるベストプラクティスです。

!!! note
	アプリケーションはログ出力の方法を汎用的で単純なものにし、ログソリューションから疎結合にしておくべきですが、ログデータの送信には `stdout` からデータをファイルに送信する[ログコレクター](../../tools/logs/)が必要です。重要なのは、アプリケーションとビジネスロジックがログインフラストラクチャに依存しないよう、関心の分離を図ることです。

!!! success
	アプリケーションとログ管理を分離することで、コード変更なしにソリューションを適応・進化させることができ、環境への変更の[Blast Radius](../../faq/#what-is-a-blast-radius)を最小限に抑えられます。
